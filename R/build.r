#' Build complete static documentation for a package.
#'
#' Currently, knitr builds documentation for:
#'
#' \itemize{
#'   \item Rd files.  Files
#'   \item Demos. Must be listed in \file{demos/00index}.
#'   \item Vignettes.
#' }
#'
#' @param package path to source version of package.  See
#'   \code{\link[devtools]{as.package}} for details on how paths and package
#'   names are resolved.
#' @param base_path root directory in which to create documentation
#' @param examples include examples or not?  Examples are particularly
#'   slow to render because all code must be run, so turning them off makes
#'   it easier to tweak templates etc.
#' @export
#' @import stringr
#' @importFrom devtools load_all
#' @aliases staticdocs-package
build_package <- function(package, base_path = NULL, examples = NULL) {
  load_all(package)
  
  package <- package_info(package, base_path, examples)
  if (!file.exists(package$base_path)) dir.create(package$base_path)
  copy_bootstrap(base_path)

  package$topics <- build_topics(package)
  package <- build_vignettes(package)
  package <- build_demos(package)
  package$readme <- readme(package)
  package <- build_references(package)
  package <- build_citation(package)
  
  package <- build_index(package)
  
  # render full main pages
  build_pages(package)
  
  if (interactive()) {
    browseURL(normalizePath(file.path(base_path, "index.html")))
  }
  invisible(TRUE)
}


#' Generate all topic pages for a package.
#'
#' @export
#' @inheritParams build_package
#' @param package_info A list containing information about the package,
#'   as generated by \code{\link{package_info}}
#' @keywords internal
build_topics <- function(package) {

  # for each file, find name of one topic
  index <- package$rd_index
  paths <- file.path(package$base_path, index$file_out)

  # create columns for extra topic info
  index$title <- ""
  index$in_index <- TRUE
  
  for (i in seq_along(index$name)) {
    message("Generating ", basename(paths[[i]]))
    
    rd <- package$rd[[i]]
    html <- to_html(rd, 
      env = new.env(parent = globalenv()), 
      topic = str_replace(basename(paths[[i]]), "\\.html$", ""),
      package = package)

    html$package <- package$package
	html$version <- package$version
    render_template("topic", html, paths[[i]])
    graphics.off()

    if ("internal" %in% html$keywords) {
      index$in_index[i] <- FALSE
    }
    index$title[i] <- html$title
  }

  index
}

readme <- function(package) {
  if (!is.null(package$readme)) return(markdown(package$readme))
  
  path <- file.path(package$path, "README.md")
  # use package description if no README.md file exists 
  if (!file.exists(path)) return(markdown(package$description))
  
  markdown(path = path)
}

copy_bootstrap <- function(base_path) {
  bootstrap <- file.path(inst_path(), "bootstrap")
  file.copy(dir(bootstrap, full.names = TRUE), base_path, recursive = TRUE)
}


#' List all package vignettes.
#'
#' Copies all vignettes and returns data structure suitable for use with
#' whisker templates.
#'
#' @keywords internal
#' @inheritParams tools::buildVignettes
#' @importFrom tools buildVignettes
#' @return a list, with one element for each vignette containing the vignette
#'   title and file name.
build_vignettes <- function(package) {  
  # Locate source and built versions of vignettes
  path <- dir(file.path(package$path, c("inst/doc", "vignettes")), ".Rnw", 
    full.names = TRUE)
  if (length(path) == 0) return(package)
  
  message("Building vignettes")
  buildVignettes(dir = package$path)
  
  message("Copying vignettes")
  src <- str_replace(path, "\\.Rnw$", ".pdf")
  filename <- basename(src)
  dest <- file.path(package$base_path, "vignettes")

  if (!file.exists(dest)) dir.create(dest)
  file.copy(src, file.path(dest, filename))  

  # Extract titles
  title <- vapply(path, FUN.VALUE = character(1), function(x) {
    contents <- str_c(readLines(x), collapse = "\n")
    str_match(contents, "\\\\VignetteIndexEntry\\{(.*?)\\}")[2]
  })  
  
  package$vignettes <- unname(apply(cbind(filename, title), 1, as.list))
  package$hasVignettes <- length(package$vignettes) > 0L
  # return modified package
  package
}


#' Creates a Bibliography Page
#' 
#' @param package package name or object
#' @param outpath output path. If missing it is taken from \code{package}
#' 
#' @keywords internal
#' @return package object updated with reference data 
#' @importFrom bibtex read.bib
build_references <- function(package, outpath=NULL){
	
	# pre-process arguments
	package <- as.package(package)
	if( is.null(outpath) ) outpath <- package$base_path
	
	# look for reference file in inst/
	ref <- inst_path(package, 'REFERENCES.bib')
	if( !file.exists(ref) ) return(package)
	
	outfile <- file.path(outpath, '_REFERENCES.html') 
	message("Generating ", basename(outfile))
	# load bibtex items
	bibs <- read.bib(ref)
	# format
	package$references <- lapply(format(bibs, style='html'), function(x) list(bibitems=x))
	
	# render dedicated file
	render_template("references", package, outfile)
	# add dedicated head link
	package <- add_headlink(package, basename(outfile), 'References')
	
	invisible(package)
}

#' @importFrom utils readCitationFile
build_citation <- function(package){
	
	citfile <- inst_path(package, 'CITATION')
	if( !file.exists(citfile) ) return(package)
	cit <- readCitationFile(citfile)
	# only extract first one
	package$citation <- gsub("(^<p>)|(</p>$)","",format(cit[[1L]], style='html'))
	# return modified package
	package
}

build_demos <- function(package, index, outpath=NULL) {
  
  # pre-process arguments
  package <- as.package(package)
  if( is.null(outpath) ) outpath <- package$base_path
  
  demo_dir <- file.path(package$path, "demo")
  if (!file.exists(demo_dir)) return(package)
  
  message("Rendering demos")
  demos <- readLines(file.path(demo_dir, "00Index"))
  
  pieces <- str_split_fixed(demos, "\\s+", 2)
  in_path <- str_c(pieces[, 1], ".r")
  filename <- str_c("demo-", pieces[,1], ".html")
  title <- pieces[, 2]
  
  # copy package object to modify 'title' tag, but not in the returned object
  lpackage <- package
  for(i in seq_along(title)) {
    demo_code <- readLines(file.path(demo_dir, in_path[i]))
    demo_expr <- evaluate(demo_code, new.env(parent = globalenv()))

	lpackage$demo <- replay_html(demo_expr,
      package = lpackage, 
      name = str_c(pieces[i], "-"))
	lpackage$title <- title[i]
    render_template("demo", lpackage, 
      file.path(lpackage$base_path, filename[i]))
  }
  
  # store demo data
  package$demos <- unname(apply(cbind(filename, title), 1, as.list))
  package$hasDemos <- length(package$demos) > 0L
  
  # render dedicated file
  outfile <- file.path(outpath, '_DEMOS.html')
  message("Generating ", basename(outfile))
  render_template("demos", package, outfile)
  # add dedicated head link
  package <- add_headlink(package, basename(outfile), 'Demos')
  
  # return updated package
  package
}

# wrap a content into the main layout
wrap_page <- local({
	.cache <- NULL
	function(package, file, layout='layout'){	
		if( is.null(package) ){ # reset cache
			.cache <<- NULL
			return()
		}

		# append prefix 'layout-' if necessary
		if( !grepl("^layout", layout) ) layout <- str_c('layout-', layout)

		# render template once
		if( is.null(.cache) ){
			lpackage <- package
			# escape tag {{{contents}}}
			lpackage$contents <- "{{{contents}}}"
			# generate navigation bar
			lpackage$navbar <- paste(capture.output(render_template("navbar", lpackage)), collapse="\n")
			# render outer layout
			.cache <<- capture.output(render_template(layout, lpackage))
		}
		
		sapply(file, function(f){
			# collapse contents
			contents <- paste(readLines(f, warn=FALSE), collapse="\n")
			# substitute in layout template
			rendered <- whisker.render(.cache, list(contents=contents))
			cat(rendered, file = f)
		})
		invisible()
	}
})

add_headlink <- function(package, target, face=target, head=FALSE){
	
	if( is.null(face) ) face <- target
	package$headlinks <- 
			if( !head ){ 
				c(package$headlinks, list(list(target=target, face=face)))
			}else{
				c(list(list(target=target, face=face)), package$headlinks)
			}
	package
}
#' Build Pages from a Layout
#' 
#' @inheritParams build_references
#' 
#' @keywords internal
#' 
build_pages <- function(package, outpath=NULL, layout='default') {
	
	# pre-process arguments
	package <- as.package(package)
	if( is.null(outpath) ) outpath <- package$base_path
	
	wrap_page(NULL)
	# substitute head links in all html files starting with '_'
	files <- dir(outpath, pattern="^_.*\\.html", full.names=TRUE)
	files <- c(file.path(outpath,'index.html'), files)
	message("Wrapping pages in layout:", layout)
	wrap_page(package, files, layout=layout)

}
